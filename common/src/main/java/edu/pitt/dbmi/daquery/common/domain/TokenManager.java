package edu.pitt.dbmi.daquery.common.domain;

import java.io.IOException;
import java.security.Key;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

import edu.pitt.dbmi.daquery.common.auth.TokenInvalidException;
import edu.pitt.dbmi.daquery.common.util.KeyGenerator;
import edu.pitt.dbmi.daquery.common.util.TokenException;
import edu.pitt.dbmi.daquery.common.util.WSConnectionUtil;
import edu.pitt.dbmi.daquery.common.util.StringHelper;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;

public class TokenManager {
		
	/**
	 * This class contains attributes used by the TokenManager to manage the tokens.
	 * The class keeps an expiration timestamp, the token key, and the token itself.
	 * The timestamp allows the manager to remove expired tokens, the key allows the 
	 * manager to access the contents of the token and check its validity.
	 * @author devuser
	 *
	 */
	public class KeyedJWT {
		private Key token_key;
		private JsonWebToken token;
		private long expDate;
		
		public KeyedJWT(Key newkey, JsonWebToken newtoken) {
			this.token_key = newkey;
			this.token = newtoken;
			this.expDate = newtoken.getExpiration();
		}

		public Key getTokenKey() {
			return token_key;
		}

		public void setTokenKey(Key token_key) {
			this.token_key = token_key;
		}

		public JsonWebToken getToken() {
			return token;
		}

		public void setToken(JsonWebToken token) {
			this.token = token;
		}
		
		public long getExpirationDate() {
			return expDate;
		}
		
		public void setExpirationDate(long newdate) {
			this.expDate = newdate;
		}
	}
	
	//The private instance of the singleton
	private static TokenManager manager = null;
	//The HashMap the manager uses to keep track of the tokens in the system
	private HashMap<String, KeyedJWT>tokenTable = null;
	//a variable to adjust the expiration time for all tokens generated by the manager
	private static int expirationMinutes = 15;

	public static void main(String[] args) {
		TokenManager tm = TokenManager.getTokenManager();
		try {
		String tokenClaimsString = tm.addToken("userId", "siteId", "networkId");
		System.out.println(tokenClaimsString);
		KeyedJWT kj = tm.getToken(tokenClaimsString);
		JsonWebToken jwt =kj.getToken();
		System.out.println("here: [" + jwt.getNetworkId() + "]");
		String renewedClaimsString = tm.renewToken(tokenClaimsString, "renewedNetworkId");
		kj = tm.getToken(renewedClaimsString);
		jwt =kj.getToken();
		System.out.println("here: [" + jwt.getNetworkId() + "]");
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		
	}
	
	/**
	 * The private constructor for this class.  Create a tokenTable on initialization.
	 */
	private TokenManager() {
		tokenTable = new HashMap<String, KeyedJWT>();
	}
	
	/**
	 * The public accessor to return the token manager instance
	 * This method is synchronized to avoid multiple threads from clearing expired tokens
	 * @return- the current instance of the TokenManager object
	 */
	public synchronized static TokenManager getTokenManager() {
		if (manager == null) {
			manager = new TokenManager();
		}
		manager.clearExpiredTokens();
		return manager;		
	}

	public static int getExpirationMinutes() {
		return expirationMinutes;
	}
	
	public static void setExpirationMinutes(int newminutes) {
		expirationMinutes = newminutes;
	}
	
	/**
	 * Loop through the list of tokens and delete any expired tokens
	 */
	private void clearExpiredTokens() {
		System.out.println("@@@@@@@ Clearing expired tokens.  Starting Key list: " + tokenTable.keySet().toString());
		List<String> invalidTokens = new ArrayList<String>();
		if (tokenTable == null) {
			return;
		}
		if (tokenTable.isEmpty()) {
			return;
		}
		for (KeyedJWT kj : tokenTable.values() ) {
			Key tokenkey = kj.getTokenKey();
			String token = kj.getToken().getTokenString();
			long exp = kj.getExpirationDate();
	        Calendar date = Calendar.getInstance();
	        long t=date.getTimeInMillis();
	        //the expcutoff represents the current time, plus a delta of one minute 
	        long expcutoff = t + (60000);
	        if (exp < expcutoff) {
	        	invalidTokens.add(token);
	        }

		}
		for (String token : invalidTokens) {
			try {
				deleteToken(token);
			} catch (TokenException e) {
				e.printStackTrace();
			}
		}
		System.out.println("@@@@@@@ Clearing expired tokens.  Ending Key list: " + tokenTable.keySet().toString());
	}
	
	/**
	 * Create a new token and add it to the token list
	 * @param userUuid- the user UUID associated with the new token
	 * @param siteUUID- the site UUID associated with the new token
	 * @param networkUUID- the network UUID associated with the new token
	 * @return- a String representing the new token
	 * @throws IOException
	 * @throws JsonMappingException
	 * @throws TokenException
	 * @throws TokenInvalidException
	 * @throws JsonParseException
	 */
	public String addToken(String userUuid, String siteUUID, String networkUUID) throws IOException, JsonMappingException, TokenException, TokenInvalidException, JsonParseException {
		Key token_key = generateTokenKey();
		String tokenid = generateTokenId();
		JsonWebToken jwt = new JsonWebToken(userUuid, siteUUID, networkUUID, tokenid, token_key);
		KeyedJWT keyjwt = manager.new KeyedJWT(token_key, jwt);
		String tokenString = keyjwt.getToken().getTokenString();
		addToken(keyjwt);
        System.out.println("@@@@@@@ IN ADDD Token String: [" + keyjwt.getToken().getTokenString() + " ] networkid: [" + keyjwt.getToken().getNetworkId() + "]" );

		return tokenString;
	}

	/**
	 * Create a new copy of an existing token with an updated issue date and new expiration date.
	 * The steps for this process:
	 * 1.  Extract the user UUID, site UUID, and network UUID from the oldTokenString
	 * 2.  Delete the oldTokenString from the TokenManager token list
	 * 3.  Create a new token using the user UUID, site UUID, and network UUID from the oldTokenString
	 * 		with a new issue timestamp and expiration timestamp
	 * 4.  Add the new token to the TokenMAnager token list
	 * @param oldTokenString- the old token string containing the user UUID, site UUID, and network UUID
	 * @return- a String representing the new token
	 * @throws IOException
	 * @throws JsonMappingException
	 * @throws TokenException
	 * @throws TokenInvalidException
	 * @throws JsonParseException
	 */
	public String renewToken(String oldTokenString) throws IOException, JsonMappingException, TokenException, TokenInvalidException, JsonParseException {
		return renewToken(oldTokenString, "");
	}

	/**
	 * Create a new copy of an existing token with an updated issue date and new expiration date.
	 * This version of the method also assigns a networkid to the new token.  This method will be called
	 * when the user switches networks.
	 * The steps for this process:
	 * 1.  Extract the user UUID, site UUID, and network UUID from the oldTokenString
	 * 2.  Delete the oldTokenString from the TokenManager token list
	 * 3.  Create a new token using the user UUID, site UUID, and network UUID from the oldTokenString
	 * 		with a new issue timestamp and expiration timestamp
	 * 4.  Add the new token to the TokenMAnager token list
	 * @param oldTokenString- the old token string containing the user UUID, site UUID, and network UUID
	 * @param networkid
	 * @return- a String representing the new token
	 * @throws IOException
	 * @throws JsonMappingException
	 * @throws TokenException
	 * @throws TokenInvalidException
	 * @throws JsonParseException
	 */
	public String renewToken(String oldTokenString, String networkid) throws IOException, JsonMappingException, TokenException, TokenInvalidException, JsonParseException {
		while (oldTokenString.startsWith("Bearer ")) {
			oldTokenString = oldTokenString.substring(6).trim();
		}
		KeyedJWT kj = getToken(oldTokenString);
		JsonWebToken jwt = kj.getToken();
		deleteToken(oldTokenString);
		if(networkid.equalsIgnoreCase("")){
			networkid = jwt.getNetworkId();
		}
		String newToken =  addToken(jwt.getUserId(), jwt.getSiteId(), networkid);		
		return newToken;
	}

	/**
	 * Add a KeyedJWT to the token list.  
	 * @param tokenString
	 * @param new_keyjwt
	 * @throws TokenException- throw an exception if the token already exists in the token list
	 */
	public void addToken(KeyedJWT new_keyjwt) throws TokenException {
		
		if (tokenTable.containsKey(new_keyjwt.getToken().getTokenId())) {
			throw new TokenException("Duplicate token found.  Token " + new_keyjwt.getToken().getTokenHash() + " already exists in token table.");
		}
		if (new_keyjwt.getToken().getNetworkId() == null) {
			System.out.println("!!!!!! IN ADDD Token String: [" + new_keyjwt.getToken().getTokenHash() + " ] networkid: [" + new_keyjwt.getToken().getNetworkId() + "]" );

		}
			
		
		tokenTable.put(new_keyjwt.getToken().getTokenId(), new_keyjwt);		
	}
	
	/**
	 * Remove the token represented by the tokenString from the token list
	 * @param tokenString
	 * @throws TokenException
	 */
	public void deleteToken(String tokenString) throws TokenException {
		try {
			Map<String, Object> claims = WSConnectionUtil.extractClaims(tokenString);
			String tokenid = JsonWebToken.extractTokenId(claims);
			KeyedJWT retToken = tokenTable.remove(tokenid);
			if (retToken == null) {
				throw new TokenException("No token found.  Cannot delete token " + tokenString + " not found in token table.");						
			}
		} catch (Exception e) {
			throw new TokenException("Unexpected error.  Cannot delete token " + tokenString + " not found in token table.  Error: " + e.getMessage());									
		}
	}
	
	/**
	 * Return a KeyedJWT object represented by the tokenString
	 * @param tokenString
	 * @return- a KeyedJWT object representing the tokenString
	 * @throws TokenException- throw an exception if the tokenString is not found
	 */
	public KeyedJWT getToken(String tokenString) throws TokenException {
		KeyedJWT retToken = null;
		try {
			//use a while loop in case Bearer gets added multiple times
			while (tokenString.startsWith("Bearer ")) {
				tokenString = tokenString.substring(6).trim();
			}
			Map<String, Object> claims = WSConnectionUtil.extractClaims(tokenString);
			String tokenid = JsonWebToken.extractTokenId(claims);
			retToken = tokenTable.get(tokenid);
			if (retToken == null) {
				String strMsg = "Looking for key: [" + tokenid + "].  Here is list of keys: " + tokenTable.keySet().toString();
				//no Tolkien found
				throw new TokenException("No token found.  Token " + tokenString + " not found in token table." + strMsg);			
			}	
			
			if (retToken.getToken().getNetworkId() == null) {
				System.out.println("!!!!!!! IN GETTT Token String: [" + retToken.getToken().getTokenString() + " ] networkid: [" + retToken.getToken().getNetworkId() + "]" );
			} else {
				System.out.println("!!!!!!! IN GETTT Token String: [" + retToken.getToken().getTokenString() + " ] networkid: [" + retToken.getToken().getNetworkId() + "]" );

			}
			
			return retToken;
		} catch (TokenException te) {
			throw te;
		} catch (Exception e) {
			throw new TokenException("Unexpected error parsing token.  Token " + tokenString + " cannot be parsed.  Error: " + e.getLocalizedMessage() );
		}
	}
	
	private static String generateTokenId() {
		String retString = UUID.randomUUID().toString();
		return retString;
	}

    public static Key generateTokenKey() {
    	String keyString = UUID.randomUUID().toString();
        Key key = new SecretKeySpec(keyString.getBytes(), 0, keyString.getBytes().length, "DES");
        return key;
    }
    
	
}
