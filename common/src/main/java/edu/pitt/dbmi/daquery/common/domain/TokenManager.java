package edu.pitt.dbmi.daquery.common.domain;

import java.io.IOException;
import java.security.Key;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.crypto.spec.SecretKeySpec;

import edu.pitt.dbmi.daquery.common.auth.TokenInvalidException;
import edu.pitt.dbmi.daquery.common.util.KeyGenerator;
import edu.pitt.dbmi.daquery.common.util.TokenException;
import edu.pitt.dbmi.daquery.common.util.StringHelper;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;

public class TokenManager {
		
	/**
	 * This class contains attributes used by the TokenManager to manage the tokens.
	 * The class keeps an expiration timestamp, the token key, and the token itself.
	 * The timestamp allows the manager to remove expired tokens, the key allows the 
	 * manager to access the contents of the token and check its validity.
	 * @author devuser
	 *
	 */
	public class KeyedJWT {
		private Key token_key;
		private JsonWebToken token;
		private long expDate;
		
		public KeyedJWT(Key newkey, JsonWebToken newtoken) {
			this.token_key = newkey;
			this.token = newtoken;
			this.expDate = newtoken.getExpiration();
		}

		public Key getTokenKey() {
			return token_key;
		}

		public void setTokenKey(Key token_key) {
			this.token_key = token_key;
		}

		public JsonWebToken getToken() {
			return token;
		}

		public void setToken(JsonWebToken token) {
			this.token = token;
		}
		
		public long getExpirationDate() {
			return expDate;
		}
		
		public void setExpirationDate(long newdate) {
			this.expDate = newdate;
		}
	}
	
	//The private instance of the singleton
	private static TokenManager manager = null;
	//The HashMap the manager uses to keep track of the tokens in the system
	private HashMap<String, KeyedJWT>tokenTable = null;
	//a variable to adjust the expiration time for all tokens generated by the manager
	private static int expirationMinutes = 1;
	
	/**
	 * The private constructor for this class.  Create a tokenTable on initialization.
	 */
	private TokenManager() {
		tokenTable = new HashMap<String, KeyedJWT>();
	}
	
	/**
	 * The public accessor to return the token manager instance
	 * This method is synchronized to avoid multiple threads from clearing expired tokens
	 * @return- the current instance of the TokenManager object
	 */
	public synchronized static TokenManager getTokenManager() {
		if (manager == null) {
			manager = new TokenManager();
		}
		manager.clearExpiredTokens();
		return manager;		
	}

	public static int getExpirationMinutes() {
		return expirationMinutes;
	}
	
	public static void setExpirationMinutes(int newminutes) {
		expirationMinutes = newminutes;
	}
	
	/**
	 * Loop through the list of tokens and delete any expired tokens
	 */
	private void clearExpiredTokens() {
		List<String> invalidTokens = new ArrayList<String>();
		if (tokenTable == null) {
			return;
		}
		for (KeyedJWT kj : tokenTable.values() ) {
			Key tokenkey = kj.getTokenKey();
			String token = kj.getToken().generateTokenString(tokenkey);
			long exp = kj.getExpirationDate();
	        Calendar date = Calendar.getInstance();
	        long t=date.getTimeInMillis();
	        //the expcutoff represents the current time, plus a delta of one minute 
	        long expcutoff = t + (60000);
	        if (exp < expcutoff) {
	        	invalidTokens.add(token);
	        }

		}
		for (String token : invalidTokens) {
			try {
				deleteToken(token);
			} catch (TokenException e) {
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Create a new token and add it to the token list
	 * @param userUuid- the user UUID associated with the new token
	 * @param siteUUID- the site UUID associated with the new token
	 * @param networkUUID- the network UUID associated with the new token
	 * @return- a String representing the new token
	 * @throws IOException
	 * @throws JsonMappingException
	 * @throws TokenException
	 * @throws TokenInvalidException
	 * @throws JsonParseException
	 */
	public String addToken(String userUuid, String siteUUID, String networkUUID) throws IOException, JsonMappingException, TokenException, TokenInvalidException, JsonParseException {
		Key token_key = generateTokenKey();
		String tokenid = generateTokenId();
		JsonWebToken jwt = new JsonWebToken(userUuid, siteUUID, networkUUID, tokenid, token_key);
		KeyedJWT keyjwt = manager.new KeyedJWT(token_key, jwt);
		String tokenString = keyjwt.getToken().generateTokenString(token_key);
		addToken(tokenString, keyjwt);
		return tokenString;
	}

	/**
	 * Create a new copy of an existing token with an updated issue date and new expiration date.
	 * The steps for this process:
	 * 1.  Extract the user UUID, site UUID, and network UUID from the oldTokenString
	 * 2.  Delete the oldTokenString from the TokenManager token list
	 * 3.  Create a new token using the user UUID, site UUID, and network UUID from the oldTokenString
	 * 		with a new issue timestamp and expiration timestamp
	 * 4.  Add the new token to the TokenMAnager token list
	 * @param oldTokenString- the old token string containing the user UUID, site UUID, and network UUID
	 * @return- a String representing the new token
	 * @throws IOException
	 * @throws JsonMappingException
	 * @throws TokenException
	 * @throws TokenInvalidException
	 * @throws JsonParseException
	 */
	public String renewToken(String oldTokenString) throws IOException, JsonMappingException, TokenException, TokenInvalidException, JsonParseException {
		if (oldTokenString.startsWith("Bearer ")) {
			oldTokenString = oldTokenString.substring(6);
		}
		KeyedJWT kj = getToken(oldTokenString);
		JsonWebToken jwt = kj.getToken();
		//call validate to extract the data from the token string
		jwt.validate();
		deleteToken(oldTokenString);		
		return addToken(jwt.getUserId(), jwt.getSiteId(), jwt.getNetworkId());
	}

	/**
	 * Add a KeyedJWT to the token list.  
	 * @param tokenString
	 * @param new_keyjwt
	 * @throws TokenException- throw an exception if the token already exists in the token list
	 */
	public void addToken(String tokenString, KeyedJWT new_keyjwt) throws TokenException {
		if (tokenTable.containsKey(tokenString)) {
			throw new TokenException("Duplicate token found.  Token " + tokenString + " already exists in token table.");
		}
		tokenTable.put(tokenString, new_keyjwt);		
	}
	
	/**
	 * Remove the token represented by the tokenString from the token list
	 * @param tokenString
	 * @throws TokenException
	 */
	public void deleteToken(String tokenString) throws TokenException {
		KeyedJWT retToken = tokenTable.remove(tokenString);
		if (retToken == null) {
			throw new TokenException("No token found.  Cannot delete token " + tokenString + " not found in token table.");						
		}
	}
	
	/**
	 * Return a KeyedJWT object represented by the tokenString
	 * @param tokenString
	 * @return- a KeyedJWT object representing the tokenString
	 * @throws TokenException- throw an exception if the tokenString is not found
	 */
	public KeyedJWT getToken(String tokenString) throws TokenException {
		if (tokenString.startsWith("Bearer ")) {
			tokenString = tokenString.substring(6);
		}
		KeyedJWT retToken = tokenTable.get(tokenString);
		if (retToken == null) {
			//no Tolkien found
			throw new TokenException("No token found.  Token " + tokenString + " not found in token table.");			
		}	
		return retToken;
	}
	
	private static String generateTokenId() {
		String retString = UUID.randomUUID().toString();
		return retString;
	}

    public static Key generateTokenKey() {
    	String keyString = UUID.randomUUID().toString();
        Key key = new SecretKeySpec(keyString.getBytes(), 0, keyString.getBytes().length, "DES");
        return key;
    }
    
	
}
